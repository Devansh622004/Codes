# -*- coding: utf-8 -*-
"""Exp3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lDq4uKzgsR8cUQdltwK7VjP0YZcqTIfK
"""

import heapq

# Graph representation (Adjacency List)
graph = {
    'S': ['A', 'B'],
    'A': ['C', 'D'],
    'B': ['E'],
    'C': ['G'],
    'D': ['G'],
    'E': ['G'],
    'G': []  # Goal
}

# Heuristic values (estimated cost to goal 'G')
heuristic = {
    'S': 7,
    'A': 6,
    'B': 5,
    'C': 5,
    'D': 2,
    'E': 1,
    'G': 0
}

def best_first_search(start, goal):
    visited = set()
    pq = []  # priority queue
    parent = {}  # to reconstruct the path

    heapq.heappush(pq, (heuristic[start], start))  # (priority, node)
    parent[start] = None

    while pq:
        h, node = heapq.heappop(pq)
        if node in visited:
            continue
        print(f"Visiting: {node}")
        visited.add(node)

        if node == goal:
            # Reconstruct path
            path = []
            while node is not None:
                path.append(node)
                node = parent[node]
            path.reverse()
            print("Goal found!")
            print("Path:", " -> ".join(path))
            return path

        for neighbor in graph[node]:
            if neighbor not in visited:
                heapq.heappush(pq, (heuristic[neighbor], neighbor))
                parent[neighbor] = node

    print("Goal not found.")
    return None

# Run the search
best_first_search('S', 'G')